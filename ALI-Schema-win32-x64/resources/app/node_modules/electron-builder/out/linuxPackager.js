"use strict";

const path = require("path");
const bluebird_1 = require("bluebird");
const platformPackager_1 = require("./platformPackager");
const metadata_1 = require("./metadata");
const fpm_1 = require("./targets/fpm");
const targetFactory_1 = require("./targets/targetFactory");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./util/awaiter");
exports.installPrefix = "/opt";
class LinuxPackager extends platformPackager_1.PlatformPackager {
    constructor(info) {
        super(info);
    }
    normalizePlatformSpecificBuildOptions(options) {
        if (options != null && options.description != null) {
            return options;
        } else {
            return Object.assign({
                description: this.appInfo.description
            }, options);
        }
    }
    createTargets(targets, mapper, cleanupTasks) {
        for (let name of targets) {
            if (name === "dir") {
                continue;
            }
            if (name === targetFactory_1.DEFAULT_TARGET || name === "deb") {
                mapper("deb", () => new fpm_1.FpmTarget("deb", this, cleanupTasks));
            } else if (name === "rpm" || name === "sh" || name === "freebsd" || name === "pacman" || name === "apk" || name === "p5p") {
                mapper(name, () => new fpm_1.FpmTarget(name, this, cleanupTasks));
            } else {
                mapper(name, () => targetFactory_1.createCommonTarget(name));
            }
        }
    }
    get platform() {
        return metadata_1.Platform.LINUX;
    }
    pack(outDir, arch, targets, postAsyncTasks) {
        return __awaiter(this, void 0, void 0, function* () {
            const appOutDir = this.computeAppOutDir(outDir, arch);
            yield this.doPack((yield this.computePackOptions(outDir, appOutDir, arch)), outDir, appOutDir, arch, this.platformSpecificBuildOptions);
            postAsyncTasks.push(this.packageInDistributableFormat(outDir, appOutDir, arch, targets));
        });
    }
    packageInDistributableFormat(outDir, appOutDir, arch, targets) {
        return __awaiter(this, void 0, void 0, function* () {
            // todo fix fpm - if run in parallel, get strange tar errors
            for (let t of targets) {
                if (t instanceof fpm_1.FpmTarget) {
                    const target = t.name;
                    const destination = path.join(outDir, this.generateName(target, arch, true /* on Linux we use safe name â€” without space */));
                    yield t.build(destination, target, appOutDir, arch);
                    this.dispatchArtifactCreated(destination);
                }
            }
            const promises = [];
            // https://github.com/electron-userland/electron-builder/issues/460
            // for some reasons in parallel to fmp we cannot use tar
            for (let t of targets) {
                const target = t.name;
                if (target === "zip" || target === "7z" || target.startsWith("tar.")) {
                    const destination = path.join(outDir, this.generateName(target, arch, true));
                    promises.push(this.archiveApp(target, appOutDir, destination).then(() => this.dispatchArtifactCreated(destination)));
                }
            }
            if (promises.length > 0) {
                yield bluebird_1.Promise.all(promises);
            }
        });
    }
}
exports.LinuxPackager = LinuxPackager;
//# sourceMappingURL=linuxPackager.js.map