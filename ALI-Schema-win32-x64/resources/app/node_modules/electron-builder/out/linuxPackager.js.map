{
  "version": 3,
  "file": "linuxPackager.js",
  "sourceRoot": "",
  "sources": [
    "../src/linuxPackager.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import * as path from \"path\"\nimport { Promise as BluebirdPromise } from \"bluebird\"\nimport { PlatformPackager, BuildInfo, Target } from \"./platformPackager\"\nimport { Platform, LinuxBuildOptions, Arch } from \"./metadata\"\nimport { FpmTarget } from \"./targets/fpm\"\nimport { createCommonTarget, DEFAULT_TARGET } from \"./targets/targetFactory\"\n\n//noinspection JSUnusedLocalSymbols\nconst __awaiter = require(\"./util/awaiter\")\n\nexport const installPrefix = \"/opt\"\n\nexport class LinuxPackager extends PlatformPackager<LinuxBuildOptions> {\n  constructor(info: BuildInfo) {\n    super(info)\n  }\n\n  normalizePlatformSpecificBuildOptions(options: LinuxBuildOptions | n): LinuxBuildOptions {\n    if (options != null && options.description != null) {\n      return options\n    }\n    else {\n      return Object.assign({\n        description: this.appInfo.description,\n      }, options)\n    }\n  }\n\n  createTargets(targets: Array<string>, mapper: (name: string, factory: () => Target) => void, cleanupTasks: Array<() => Promise<any>>): void {\n    for (let name of targets) {\n      if (name === \"dir\") {\n        continue\n      }\n\n      if (name === DEFAULT_TARGET || name === \"deb\") {\n        mapper(\"deb\", () => new FpmTarget(\"deb\", this, cleanupTasks))\n      }\n      else if (name === \"rpm\" || name === \"sh\" || name === \"freebsd\" || name === \"pacman\" || name === \"apk\" || name === \"p5p\") {\n        mapper(name, () => new FpmTarget(name, this,  cleanupTasks))\n      }\n      else {\n        mapper(name, () => createCommonTarget(name))\n      }\n    }\n  }\n\n  get platform() {\n    return Platform.LINUX\n  }\n\n  async pack(outDir: string, arch: Arch, targets: Array<Target>, postAsyncTasks: Array<Promise<any>>): Promise<any> {\n    const appOutDir = this.computeAppOutDir(outDir, arch)\n    await this.doPack(await this.computePackOptions(outDir, appOutDir, arch), outDir, appOutDir, arch, this.platformSpecificBuildOptions)\n\n    postAsyncTasks.push(this.packageInDistributableFormat(outDir, appOutDir, arch, targets))\n  }\n\n  protected async packageInDistributableFormat(outDir: string, appOutDir: string, arch: Arch, targets: Array<Target>): Promise<any> {\n    // todo fix fpm - if run in parallel, get strange tar errors\n    for (let t of targets) {\n      if (t instanceof FpmTarget) {\n        const target = t.name\n        const destination = path.join(outDir, this.generateName(target, arch, true /* on Linux we use safe name â€” without space */))\n        await t.build(destination, target, appOutDir, arch)\n        this.dispatchArtifactCreated(destination)\n      }\n    }\n\n    const promises: Array<Promise<any>> = []\n    // https://github.com/electron-userland/electron-builder/issues/460\n    // for some reasons in parallel to fmp we cannot use tar\n    for (let t of targets) {\n      const target = t.name\n      if (target === \"zip\" || target === \"7z\" || target.startsWith(\"tar.\")) {\n        const destination = path.join(outDir, this.generateName(target, arch, true))\n        promises.push(this.archiveApp(target, appOutDir, destination)\n          .then(() => this.dispatchArtifactCreated(destination)))\n      }\n    }\n\n    if (promises.length > 0) {\n      await BluebirdPromise.all(promises)\n    }\n  }\n}"
  ]
}
