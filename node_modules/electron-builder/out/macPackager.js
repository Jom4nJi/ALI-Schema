"use strict";

const platformPackager_1 = require("./platformPackager");
const metadata_1 = require("./metadata");
const path = require("path");
const bluebird_1 = require("bluebird");
const util_1 = require("./util/util");
const log_1 = require("./util/log");
const codeSign_1 = require("./codeSign");
const deepAssign = require("deep-assign");
const electron_osx_sign_tf_1 = require("electron-osx-sign-tf");
const dmg_1 = require("./targets/dmg");
const targetFactory_1 = require("./targets/targetFactory");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./util/awaiter");
class MacPackager extends platformPackager_1.PlatformPackager {
    constructor(info, cleanupTasks) {
        super(info);
        if (this.options.cscLink == null) {
            this.codeSigningInfo = bluebird_1.Promise.resolve(null);
        } else {
            const keychainName = codeSign_1.generateKeychainName();
            cleanupTasks.push(() => codeSign_1.deleteKeychain(keychainName));
            this.codeSigningInfo = codeSign_1.createKeychain(keychainName, this.options.cscLink, this.getCscPassword(), this.options.cscInstallerLink, this.options.cscInstallerKeyPassword);
        }
    }
    getIconPath() {
        return __awaiter(this, void 0, void 0, function* () {
            let iconPath = this.platformSpecificBuildOptions.icon || this.devMetadata.build.icon;
            if (iconPath != null && !iconPath.endsWith(".icns")) {
                iconPath += ".icns";
            }
            return iconPath == null ? yield this.getDefaultIcon("icns") : path.resolve(this.projectDir, iconPath);
        });
    }
    normalizePlatformSpecificBuildOptions(options) {
        return super.normalizePlatformSpecificBuildOptions(options == null ? this.info.devMetadata.build.osx : options);
    }
    createTargets(targets, mapper, cleanupTasks) {
        for (let name of targets) {
            if (name === "dir") {
                continue;
            }
            if (name === targetFactory_1.DEFAULT_TARGET) {
                mapper("dmg", () => new dmg_1.DmgTarget(this));
                mapper("zip", () => new platformPackager_1.Target("zip"));
            } else if (name === "dmg") {
                mapper("dmg", () => new dmg_1.DmgTarget(this));
            } else {
                mapper(name, () => name === "mas" ? new platformPackager_1.Target("mas") : targetFactory_1.createCommonTarget(name));
            }
        }
    }
    get platform() {
        return metadata_1.Platform.MAC;
    }
    pack(outDir, arch, targets, postAsyncTasks) {
        return __awaiter(this, void 0, void 0, function* () {
            const packOptions = yield this.computePackOptions(outDir, this.computeAppOutDir(outDir, arch), arch);
            let nonMasPromise = null;
            const hasMas = targets.length !== 0 && targets.some(it => it.name === "mas");
            if (!hasMas || targets.length > 1) {
                const appOutDir = this.computeAppOutDir(outDir, arch);
                nonMasPromise = this.doPack(packOptions, outDir, appOutDir, arch, this.platformSpecificBuildOptions).then(() => this.sign(appOutDir, null)).then(() => {
                    this.packageInDistributableFormat(appOutDir, targets, postAsyncTasks);
                });
            }
            if (hasMas) {
                // osx-sign - disable warning
                const appOutDir = path.join(outDir, "mas");
                const masBuildOptions = deepAssign({}, this.platformSpecificBuildOptions, this.devMetadata.build["mas"]);
                //noinspection JSUnusedGlobalSymbols
                yield this.doPack(Object.assign({}, packOptions, {
                    platform: "mas",
                    "osx-sign": false,
                    generateFinalBasename: function () {
                        return "mas";
                    }
                }), outDir, appOutDir, arch, masBuildOptions);
                yield this.sign(appOutDir, masBuildOptions);
            }
            if (nonMasPromise != null) {
                yield nonMasPromise;
            }
        });
    }
    static findIdentity(certType, name) {
        return __awaiter(this, void 0, void 0, function* () {
            let identity = process.env.CSC_NAME || name;
            if (util_1.isEmptyOrSpaces(identity)) {
                if (process.env.CSC_IDENTITY_AUTO_DISCOVERY === "false") {
                    return null;
                }
                return yield codeSign_1.findIdentity(certType);
            } else {
                identity = identity.trim();
                for (let prefix of codeSign_1.appleCertificatePrefixes) {
                    checkPrefix(identity, prefix);
                }
                const result = yield codeSign_1.findIdentity(certType, identity);
                if (result == null) {
                    throw new Error(`Identity name "${ identity }" is specified, but no valid identity with this name in the keychain`);
                }
                return result;
            }
        });
    }
    sign(appOutDir, masOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let codeSigningInfo = yield this.codeSigningInfo;
            if (codeSigningInfo == null) {
                if (process.env.CSC_LINK != null) {
                    throw new Error("codeSigningInfo is null, but CSC_LINK defined");
                }
                const identity = yield MacPackager.findIdentity(masOptions == null ? "Developer ID Application" : "3rd Party Mac Developer Application", this.platformSpecificBuildOptions.identity);
                if (identity == null) {
                    const message = "App is not signed: CSC_LINK or CSC_NAME are not specified, and no valid identity in the keychain, see https://github.com/electron-userland/electron-builder/wiki/Code-Signing";
                    if (masOptions == null) {
                        log_1.warn(message);
                        return;
                    } else {
                        throw new Error(message);
                    }
                }
                if (masOptions != null) {
                    const installerName = masOptions == null ? null : yield MacPackager.findIdentity("3rd Party Mac Developer Installer", this.platformSpecificBuildOptions.identity);
                    if (installerName == null) {
                        throw new Error("Cannot find valid installer certificate: CSC_LINK or CSC_NAME are not specified, and no valid identity in the keychain, see https://github.com/electron-userland/electron-builder/wiki/Code-Signing");
                    }
                    codeSigningInfo = {
                        name: identity,
                        installerName: installerName
                    };
                } else {
                    codeSigningInfo = {
                        name: identity
                    };
                }
            } else {
                if (codeSigningInfo.name == null && masOptions == null) {
                    throw new Error("codeSigningInfo.name is null, but CSC_LINK defined");
                }
                if (masOptions != null && codeSigningInfo.installerName == null) {
                    throw new Error("Signing is required for mas builds but CSC_INSTALLER_LINK is not specified");
                }
            }
            const identity = codeSigningInfo.name;
            const baseSignOptions = {
                app: path.join(appOutDir, `${ this.appInfo.productName }.app`),
                platform: masOptions == null ? "darwin" : "mas",
                keychain: codeSigningInfo.keychainName,
                version: this.info.electronVersion
            };
            const signOptions = Object.assign({
                identity: identity
            }, this.devMetadata.build["osx-sign"], baseSignOptions);
            const resourceList = yield this.resourceList;
            const customSignOptions = masOptions || this.platformSpecificBuildOptions;
            if (customSignOptions.entitlements != null) {
                signOptions.entitlements = customSignOptions.entitlements;
            } else {
                const p = `entitlements.${ masOptions == null ? "osx" : "mas" }.plist`;
                if (resourceList.indexOf(p) !== -1) {
                    signOptions.entitlements = path.join(this.buildResourcesDir, p);
                }
            }
            if (customSignOptions.entitlementsInherit != null) {
                signOptions["entitlements-inherit"] = customSignOptions.entitlementsInherit;
            } else {
                const p = `entitlements.${ masOptions == null ? "osx" : "mas" }.inherit.plist`;
                if (resourceList.indexOf(p) !== -1) {
                    signOptions["entitlements-inherit"] = path.join(this.buildResourcesDir, p);
                }
            }
            yield log_1.task(`Signing app (identity: ${ identity })`, this.doSign(signOptions));
            if (masOptions != null) {
                const pkg = path.join(appOutDir, `${ this.appInfo.productName }-${ this.appInfo.version }.pkg`);
                yield this.doFlat(Object.assign({
                    pkg: pkg,
                    identity: codeSigningInfo.installerName
                }, baseSignOptions));
                this.dispatchArtifactCreated(pkg, `${ this.appInfo.name }-${ this.appInfo.version }.pkg`);
            }
        });
    }
    //noinspection JSMethodCanBeStatic
    doSign(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return electron_osx_sign_tf_1.signAsync(opts);
        });
    }
    //noinspection JSMethodCanBeStatic
    doFlat(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return electron_osx_sign_tf_1.flatAsync(opts);
        });
    }
    packageInDistributableFormat(appOutDir, targets, promises) {
        for (let t of targets) {
            const target = t.name;
            if (t instanceof dmg_1.DmgTarget) {
                promises.push(t.build(appOutDir));
            } else if (target !== "mas") {
                log_1.log(`Creating MacOS ${ target }`);
                // we use app name here - see https://github.com/electron-userland/electron-builder/pull/204
                const outFile = path.join(appOutDir, this.generateName2(target, "mac", false));
                promises.push(this.archiveApp(target, appOutDir, outFile).then(() => this.dispatchArtifactCreated(outFile, this.generateName2(target, "mac", true))));
            }
        }
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MacPackager;
function checkPrefix(name, prefix) {
    if (name.startsWith(prefix)) {
        throw new Error(`Please remove prefix "${ prefix }" from the specified name — appropriate certificate will be chosen automatically`);
    }
}
//# sourceMappingURL=macPackager.js.map