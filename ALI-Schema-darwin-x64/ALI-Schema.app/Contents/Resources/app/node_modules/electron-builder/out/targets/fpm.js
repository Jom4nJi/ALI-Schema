"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const metadata_1 = require("../metadata");
const platformPackager_1 = require("../platformPackager");
const util_1 = require("../util/util");
const linuxPackager_1 = require("../linuxPackager");
const path = require("path");
const binDownload_1 = require("../util/binDownload");
const os_1 = require("os");
const fs_extra_p_1 = require("fs-extra-p");
const bluebird_1 = require("bluebird");
const template = require("lodash.template");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("../util/awaiter");
class FpmTarget extends platformPackager_1.Target {
    constructor(name, packager, cleanupTasks) {
        super(name);
        this.packager = packager;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.devMetadata.build[this.name]);
        const tempDir = path.join(os_1.tmpdir(), util_1.getTempName("electron-builder-linux"));
        const tempDirPromise = fs_extra_p_1.emptyDir(tempDir).then(() => {
            cleanupTasks.push(() => fs_extra_p_1.remove(tempDir));
            return tempDir;
        });
        this.packageFiles = this.computePackageFiles(tempDirPromise);
        this.scriptFiles = this.createScripts(tempDirPromise);
        if (process.platform === "win32" || process.env.USE_SYSTEM_FPM === "true") {
            this.fpmPath = bluebird_1.Promise.resolve("fpm");
        } else {
            this.fpmPath = binDownload_1.downloadFpm(process.platform === "darwin" ? "1.5.1-20150715-2.2.2" : "1.5.0-2.3.1", process.platform === "darwin" ? "osx" : `linux-x86${ process.arch === "ia32" ? "" : "_64" }`);
        }
    }
    computePackageFiles(tempDirPromise) {
        return __awaiter(this, void 0, void 0, function* () {
            const tempDir = yield tempDirPromise;
            const promises = [];
            if (this.packager.platformSpecificBuildOptions.desktop == null) {
                promises.push(this.computeDesktopIconPath(tempDir));
            }
            promises.push(this.computeDesktop(tempDir));
            return Array.prototype.concat.apply([], (yield bluebird_1.Promise.all(promises)));
        });
    }
    // must be name without spaces and other special characters, but not product name used
    computeDesktopIconPath(tempDir) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const mappings = [];
                const pngIconsDir = path.join(this.packager.buildResourcesDir, "icons");
                for (let file of yield fs_extra_p_1.readdir(pngIconsDir)) {
                    if (file.endsWith(".png") || file.endsWith(".PNG")) {
                        // If parseInt encounters a character that is not a numeral in the specified radix,
                        // it returns the integer value parsed up to that point
                        try {
                            const size = parseInt(file, 10);
                            if (size > 0) {
                                mappings.push(`${ pngIconsDir }/${ file }=/usr/share/icons/hicolor/${ size }x${ size }/apps/${ this.packager.appInfo.name }.png`);
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }
                return mappings;
            } catch (e) {
                return this.createFromIcns(tempDir);
            }
        });
    }
    createScripts(tempDirPromise) {
        return __awaiter(this, void 0, void 0, function* () {
            const tempDir = yield tempDirPromise;
            const defaultTemplatesDir = path.join(__dirname, "..", "..", "templates", "linux");
            const templateOptions = Object.assign({
                // old API compatibility
                executable: this.packager.appInfo.productName
            }, this.packager.platformSpecificBuildOptions);
            const afterInstallTemplate = this.packager.platformSpecificBuildOptions.afterInstall || path.join(defaultTemplatesDir, "after-install.tpl");
            const afterInstallFilePath = writeConfigFile(tempDir, afterInstallTemplate, templateOptions);
            const afterRemoveTemplate = this.packager.platformSpecificBuildOptions.afterRemove || path.join(defaultTemplatesDir, "after-remove.tpl");
            const afterRemoveFilePath = writeConfigFile(tempDir, afterRemoveTemplate, templateOptions);
            return yield bluebird_1.Promise.all([afterInstallFilePath, afterRemoveFilePath]);
        });
    }
    build(destination, target, appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            const scripts = yield this.scriptFiles;
            const packager = this.packager;
            const appInfo = packager.appInfo;
            const projectUrl = yield appInfo.computePackageUrl();
            if (projectUrl == null) {
                throw new Error("Please specify project homepage, see https://github.com/electron-userland/electron-builder/wiki/Options#AppMetadata-homepage");
            }
            const options = this.options;
            const author = options.maintainer || `${ packager.metadata.author.name } <${ packager.metadata.author.email }>`;
            const synopsis = options.synopsis;
            const args = ["-s", "dir", "-t", target, "--architecture", arch === metadata_1.Arch.ia32 ? "i386" : "amd64", "--name", appInfo.name, "--force", "--after-install", scripts[0], "--after-remove", scripts[1], "--description", platformPackager_1.smarten(target === "rpm" ? options.description : `${ synopsis || "" }\n ${ options.description }`), "--maintainer", author, "--vendor", options.vendor || author, "--version", appInfo.version, "--package", destination, "--url", projectUrl];
            if (target === "deb") {
                args.push("--deb-compression", options.compression || (packager.devMetadata.build.compression === "store" ? "gz" : "xz"));
            } else if (target === "rpm") {
                // args.push("--rpm-compression", options.compression || (this.devMetadata.build.compression === "store" ? "none" : "xz"))
                args.push("--rpm-os", "linux");
                if (synopsis != null) {
                    args.push("--rpm-summary", platformPackager_1.smarten(synopsis));
                }
            }
            let depends = options.depends;
            if (depends == null) {
                if (target === "deb") {
                    depends = ["libappindicator1", "libnotify-bin"];
                } else {
                    depends = [];
                }
            } else if (!Array.isArray(depends)) {
                if (typeof depends === "string") {
                    depends = [depends];
                } else {
                    throw new Error(`depends must be Array or String, but specified as: ${ depends }`);
                }
            }
            for (let dep of depends) {
                args.push("--depends", dep);
            }
            util_1.use(packager.metadata.license || packager.devMetadata.license, it => args.push("--license", it));
            util_1.use(appInfo.buildNumber, it => args.push("--iteration", it));
            util_1.use(options.fpm, it => args.push.apply(args, _toConsumableArray(it)));
            args.push(`${ appOutDir }/=${ linuxPackager_1.installPrefix }/${ appInfo.productName }`);
            args.push.apply(args, _toConsumableArray((yield this.packageFiles)));
            yield util_1.exec((yield this.fpmPath), args);
        });
    }
    computeDesktop(tempDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const appInfo = this.packager.appInfo;
            const tempFile = path.join(tempDir, appInfo.productName + ".desktop");
            yield fs_extra_p_1.outputFile(tempFile, this.packager.platformSpecificBuildOptions.desktop || `[Desktop Entry]
Name=${ appInfo.productName }
Comment=${ this.packager.platformSpecificBuildOptions.description || appInfo.description }
Exec="${ linuxPackager_1.installPrefix }/${ appInfo.productName }/${ appInfo.productName }"
Terminal=false
Type=Application
Icon=${ appInfo.name }
`);
            return [`${ tempFile }=/usr/share/applications/${ appInfo.productName }.desktop`];
        });
    }
    createFromIcns(tempDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield util_1.exec("icns2png", ["-x", "-o", tempDir, path.join(this.packager.buildResourcesDir, "icon.icns")]);
            util_1.debug(output);
            const imagePath = path.join(tempDir, "icon_256x256x32.png");
            function resize(size) {
                const sizeArg = `${ size }x${ size }`;
                return util_1.exec("gm", ["convert", "-size", sizeArg, imagePath, "-resize", sizeArg, path.join(tempDir, `icon_${ size }x${ size }x32.png`)]);
            }
            const promises = [resize(24), resize(96)];
            if (!(output.indexOf("is32") !== -1)) {
                promises.push(resize(16));
            }
            if (!(output.indexOf("ih32") !== -1)) {
                promises.push(resize(48));
            }
            if (!(output.toString().indexOf("icp6") !== -1)) {
                promises.push(resize(64));
            }
            if (!(output.indexOf("it32") !== -1)) {
                promises.push(resize(128));
            }
            yield bluebird_1.Promise.all(promises);
            const appName = this.packager.appInfo.name;
            function createMapping(size) {
                return `${ tempDir }/icon_${ size }x${ size }x32.png=/usr/share/icons/hicolor/${ size }x${ size }/apps/${ appName }.png`;
            }
            return [createMapping("16"), createMapping("24"), createMapping("32"), createMapping("48"), createMapping("64"), createMapping("96"), createMapping("128"), createMapping("256"), createMapping("512")];
        });
    }
}
exports.FpmTarget = FpmTarget;
function writeConfigFile(tempDir, templatePath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = template((yield fs_extra_p_1.readFile(templatePath, "utf8")), {
            // set interpolate explicitly to avoid troubles with templating of installer.nsi.tpl
            interpolate: /<%=([\s\S]+?)%>/g
        })(options);
        const outputPath = path.join(tempDir, path.basename(templatePath, ".tpl"));
        yield fs_extra_p_1.outputFile(outputPath, config);
        return outputPath;
    });
}
//# sourceMappingURL=fpm.js.map